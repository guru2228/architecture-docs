# ADR-013: Adopt DPoP (Demonstration of Proof-of-Possession) to Protect AI Agent & Tool Calls

**Status:** Proposed
**Date:** October 28, 2025
**Owners:** Platform Security, Agent Gateway
**Deciders:** CISO, Chief Architect, Identity Lead
**Related:** Zero Trust (NIST 800-207), OAuth 2.1 rollout, Agent Identity ADR, mTLS (RFC 8705)

---

## Context

Our AI platform relies on agents (services, tools, browser/mobile apps) that exchange OAuth tokens across multiple hops (agent→tool, agent→LLM service, agent→data API). Plain **bearer tokens** are replayable if copied, enabling stolen-token abuse via prompt-injection or supply-chain leakage. We need a standard, interoperable way to **bind tokens to the legitimate sender**, even when mTLS is impractical (e.g., browsers, SPAs, serverless, cross-organization APIs). **DPoP** is an IETF standard that sender-constrains tokens at the **application layer**, designed specifically to detect replay of access/refresh tokens. ([IETF Datatracker][1])

---

## Decision

**Use DPoP for sender-constraining access and refresh tokens on all agent and tool API calls where feasible.**

* The client (agent/app) creates a per-request **DPoP proof** (a signed JWT) including the HTTP method `htm`, target URI `htu`, issued-at `iat`, unique `jti`, and—when using an access token—the token hash `ath`. The proof is sent in the `DPoP` header; the access token is sent with the `Authorization: DPoP <token>` scheme. Resource servers verify the proof and that the token is bound to the same public key. ([IETF Datatracker][1])
* The authorization server (STS) **binds** issued tokens to the client’s public key and advertises support per the spec. Binding uses the JWT `cnf` claim with a **JWK thumbprint** (`jkt`) per RFC 7800/7638. ([IETF Datatracker][1])
* Where mTLS is available and operationally simple (service-to-service on trusted networks), we may keep **certificate-bound tokens** (RFC 8705). DPoP is the default for browsers/mobile/edge and for cross-boundary calls where mTLS is not available or desirable. ([RFC Editor][2])

---

## Rationale

* **Stops token replay:** A stolen access token cannot be used without producing a matching DPoP proof (signed by the bound key) for the correct `htm`/`htu`, and with `ath` binding the exact token value. ([IETF Datatracker][1])
* **Designed for public clients:** DPoP’s primary use case includes SPAs and device apps that can’t practically do client-cert mTLS. ([IETF Datatracker][1])
* **Fits Zero Trust:** Sender-constrained tokens strengthen per-request verification and pair well with continuous evaluation. (DPoP is explicitly an app-layer alternative when mTLS/token binding aren’t feasible.) ([IETF Datatracker][1])
* **Standards-based & supported:** Defined in **RFC 9449**; widely supported by major IdPs (Okta, Auth0, Curity). ([IETF Datatracker][1])
* **Aligned with OAuth Security BCP:** Best current practice (RFC **9700**) emphasizes preventing token replay and sender-constraining powerful tokens. ([RFC Editor][3])

---

## Options Considered

| Option                    | Summary                                                | Pros                                                              | Cons                                                                                   |
| ------------------------- | ------------------------------------------------------ | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **A. DPoP (Chosen)**      | App-layer PoP; JWT proof per request; key-bound tokens | Works in browsers/mobile; replay detection; standard; IdP support | Requires proof verification at RS; key mgmt on client                                  |
| **B. mTLS-bound tokens**  | TLS-layer PoP with client certs (RFC 8705)             | Strong binding; mature                                            | Hard in browsers; brittle across proxies/CDNs; PKI ops overhead ([RFC Editor][2])      |
| **C. Bearer tokens only** | No sender constraint                                   | Simplest                                                          | Replayable; weak against token theft; non-compliant with modern BCPs ([RFC Editor][3]) |

---

## Scope

* **In scope:** Agent→Tool/LLM API calls; SPA/mobile apps; cross-org partner APIs; refresh tokens for public clients.
* **Out of scope (initial):** Legacy clients that cannot generate asymmetric keys (migrate asap).

---

## Non-Goals / Clarifications

* DPoP is **not** client authentication; it’s sender-constraining of tokens. Use PKCE/private_key_jwt/etc. as appropriate for client auth. ([IETF Datatracker][1])
* DPoP **relies on TLS** for message integrity; it signs just enough HTTP data (method+URI) to prove possession without normalizing entire messages. ([IETF Datatracker][1])

---

## Implementation Plan

1. **Authorization Server (STS)**

   * Enable DPoP token issuance; advertise in AS metadata; bind tokens with `cnf.jkt` to the client’s JWK. ([IETF Datatracker][1])
   * Support **DPoP nonces** to defeat proof pre-generation; return `DPoP-Nonce` as needed. ([IETF Datatracker][1])
2. **Resource Servers (Agent Gateway / APIs)**

   * Require `Authorization: DPoP <token>` + `DPoP: <proof>`. Validate signature, `htm`, `htu`, `iat` window, single-use `jti`, and `ath` vs. token. Reject DPoP-bound tokens presented as Bearer. ([IETF Datatracker][1])
3. **Clients (Agents/Apps)**

   * Generate and protect an asymmetric key (HW/OS keystore where possible); emit per-request DPoP proofs.
   * Rotate keys per policy; re-bind via token refresh when keys rotate. (JWT AT profile per RFC 9068 recommended.) ([IETF Datatracker][4])
4. **Fallback**

   * Keep mTLS for server-to-server paths where it’s simpler; DPoP elsewhere. ([RFC Editor][2])

---

## Security Considerations

* **Replay protection:** Enforce short proof lifetimes and **single-use `jti`** tracking; use **`ath`** to bind a proof to a specific access token. ([IETF Datatracker][1])
* **Pre-generation defense:** Use **server-provided nonces** (`DPoP-Nonce`) to defeat exfiltrated, future-dated proofs. ([IETF Datatracker][1])
* **Key protection:** Store private keys in non-exportable keystores/HSM where available; if untrusted code can run in the client context, risk increases (standard caveat noted by RFC 9449). ([IETF Datatracker][1])
* **Interoperability:** For JWT access tokens, carry `cnf.jkt`; for opaque tokens, expose `cnf.jkt` via **token introspection**. ([IETF Datatracker][1])

---

## Operational Impacts

* **Gateway logic:** Add DPoP verification path; cache AS metadata; support WWW-Authenticate challenges for DPoP. ([IETF Datatracker][1])
* **Observability:** Log `jti`, `htu`, `htm`, key thumbprint, decision reason, and nonce consumption for forensics.
* **Developer experience:** Provide client SDK helpers for proof generation and nonce handling (browsers/mobile/server). (Vendor docs & SDKs available from Okta/Auth0/Curity.) ([Okta Developer][5])

---

## Acceptance Criteria & KPIs

* **Coverage:** ≥95% of agent/tool calls use DPoP-bound tokens.
* **Replay:** 0 successful token-replay findings in red-team exercises.
* **Latency:** DPoP verification adds **≤5 ms** median at the gateway (measured).
* **Nonce efficacy:** No accepted proofs older than policy window; nonces observed where configured.
* **Interop:** Pass conformance tests with at least two major IdPs (e.g., Okta, Auth0). ([Okta Developer][5])

---

## Consequences

* **Positive:** Strong mitigation for token theft in agentic workflows; standards-based; deployable in browsers/mobile where mTLS struggles. ([RFC Editor][2])
* **Trade-offs:** Adds per-request signing/verification; requires `jti` replay cache; clients must manage keys.

---

## References

* **DPoP (Proposed Standard)**: *OAuth 2.0 Demonstrating Proof of Possession (DPoP)*, **RFC 9449** (Sept 2023). ([IETF Datatracker][1])
* **mTLS Binding**: *OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens*, **RFC 8705**. ([RFC Editor][2])
* **JWT AT Profile**: **RFC 9068**. ([IETF Datatracker][4])
* **JWT PoP `cnf` Claim**: **RFC 7800**. ([RFC Editor][6])
* **JWK Thumbprint (`jkt`)**: **RFC 7638**. ([IETF Datatracker][7])
* **OAuth 2.0 Security BCP**: **RFC 9700** (BCP 240, Jan 2025). ([RFC Editor][8])
* **Ecosystem Support**: Okta DPoP guides & announcements; Auth0 DPoP docs; Curity resources. ([Okta Developer][5])

---

### Appendix — Example (abbreviated)

**Headers**

```
Authorization: DPoP <access_token>
DPoP: <base64url(jwt header).base64url(jwt payload).base64url(signature)>
```

**DPoP proof payload (example fields)**

```json
{ "jti":"<uuid>", "htm":"POST", "htu":"https://api.example.com/tools/run",
  "iat": 1730110000, "ath":"<sha256(access_token) base64url>" }
```

(Fields and validation requirements per RFC 9449 §4–7, including nonce when supplied.) ([IETF Datatracker][1])

**Bottom line:** DPoP gives our AI agents **proof-of-possession** and **per-request binding**—turning replayable bearer tokens into sender-constrained credentials that fit real-world browser/mobile and cross-boundary agent workflows. ([IETF Datatracker][1])

[1]: https://datatracker.ietf.org/doc/html/rfc9449 "
            
                RFC 9449 - OAuth 2.0 Demonstrating Proof of Possession (DPoP)
            
        "
[2]: https://www.rfc-editor.org/rfc/rfc8705.html "RFC 8705: OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens"
[3]: https://www.rfc-editor.org/info/rfc9700?utm_source=chatgpt.com "Information on RFC 9700"
[4]: https://datatracker.ietf.org/doc/html/rfc9068?utm_source=chatgpt.com "RFC 9068 - JSON Web Token (JWT) Profile for OAuth 2.0 ..."
[5]: https://developer.okta.com/docs/guides/dpop/oktaresourceserver/main/?utm_source=chatgpt.com "Configure OAuth 2.0 Demonstrating Proof-of-Possession"
[6]: https://www.rfc-editor.org/rfc/rfc7800.html?utm_source=chatgpt.com "RFC 7800: Proof-of-Possession Key Semantics for JSON ..."
[7]: https://datatracker.ietf.org/doc/html/rfc7638?utm_source=chatgpt.com "RFC 7638 - JSON Web Key (JWK) Thumbprint"
[8]: https://www.rfc-editor.org/rfc/rfc9700?utm_source=chatgpt.com "RFC 9700: Best Current Practice for OAuth 2.0 Security"
